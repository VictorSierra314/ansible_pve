#########################################################
########## Shutdown Dev and SandBox infrastructure
---

### SHUTDOWN WEBSERVERS
- name: Shutdown webservers
  hosts: webservers
  tags: webservers_shutdown
  any_errors_fatal: true
  become: true
  gather_facts: false
  tasks:
    # Check the host status, in case of a rerun, this task will fail avoiding to run the rest.
    - name: Check guest status
      ignore_errors: true
      register: check_guest_status_result
      ansible.builtin.wait_for_connection:
        timeout: 5

    # This task will gather all active user, excluding the ansible user
    - name: Check for active connections
      when: not check_guest_status_result.failed
      failed_when: check_active_connections.stderr | length > 0
      changed_when: check_active_connections.rc == 0
      register: check_active_connections
      ansible.builtin.shell: "w -h | grep -v {{ ansible_user }}"

    # If enable_debug is set the true, the previous command ouput will be displayed.
    # If the next task fail because there is active users sessions, enabling this task can help troubleshooting.
    - name: Display live connections
      when:
        - enable_debug | default('false') | bool
        - not check_guest_status_result.failed
      ansible.builtin.debug:
        var: check_active_connections.stdout_lines

    # Based on 'Check for active connections' output, if any user are connected, this task will end the playbook
    - name: Exit the host if there is still active connection
      when:
        - check_active_connections.stdout is defined
        - check_active_connections.stdout | length > 0
      ansible.builtin.fail:
        msg: "ERROR - There is still active session in {{ inventory_hostname }}"

    - name: Shutdown hosts
      when: not check_guest_status_result.failed
      community.general.shutdown:

    # This task add additional verification. The task will fail but it should fail as timeout.
    # The output will be captured and a condition in the next task will ensure that we are getting a timeout.
    - name: Make sure that all host are offline
      when: not check_guest_status_result.failed
      ignore_errors: true
      register: check_host_shutdown_result
      ansible.builtin.wait_for_connection:
        timeout: 2

    - name: Exit the playbook if the check command does not have the expected status
      when:
        - check_host_shutdown_result.failed is defined
        - not check_host_shutdown_result.failed
      ansible.builtin.fail:
        msg: "{{ inventory_hostname }} might still be online"

### SHUTDOWN DATABASES
- name: Shutdown databases servers
  hosts: dbservers
  tags: dbservers_shutdown
  any_errors_fatal: true
  become: true
  gather_facts: false
  tasks:
    # Check the host status, in case of a rerun, this task will fail avoiding to run the rest.
    - name: Check guest status
      ignore_errors: true
      register: check_guest_status_result
      ansible.builtin.wait_for_connection:
        timeout: 5

    # This task will gather all active user, excluding the ansible user
    - name: Check for active connections
      when: not check_guest_status_result.failed
      failed_when: check_active_connections.stderr | length > 0
      changed_when: check_active_connections.rc == 0
      register: check_active_connections
      ansible.builtin.shell: "w -h | grep -v {{ ansible_user }}"

    # If enable_debug is set the true, the previous command ouput will be displayed.
    # If the next task fail because there is active users sessions, enabling this task can help troubleshooting.
    - name: Display live connections
      when:
        - enable_debug | default('false') | bool
        - not check_guest_status_result.failed
      ansible.builtin.debug:
        var: check_active_connections.stdout_lines

    # Based on 'Check for active connections' output, if any user are connected, this task will end the playbook
    - name: Exit the host if there is still active connection
      when:
        - check_active_connections.stdout is defined
        - check_active_connections.stdout | length > 0
      ansible.builtin.fail:
        msg: "ERROR - There is still active session in {{ inventory_hostname }}"

    - name: Shutdown hosts
      when: not check_guest_status_result.failed
      community.general.shutdown:

    # This task add additional verification. The task will fail but it should fail as timeout.
    # The output will be captured and a condition in the next task will ensure that we are getting a timeout.
    - name: Make sure that all host are offline
      when: not check_guest_status_result.failed
      ignore_errors: true
      register: check_host_shutdown_result
      ansible.builtin.wait_for_connection:
        timeout: 2

    - name: Exit the playbook if the check command does not have the expected status
      when:
        - check_host_shutdown_result.failed is defined
        - not check_host_shutdown_result.failed
      ansible.builtin.fail:
        msg: "{{ inventory_hostname }} might still be online"

### SHUTDOWN MANAGEMENT SERVERS
# Both active directory server are part of our management group. I excluded them in the host line.
# Both AD will be shutdown in the next task.
- name: Shutdown management servers
  hosts: mgtservers:!domain_controlers
  tags: mgtservers_shutdown
  any_errors_fatal: true
  become: true
  gather_facts: false
  tasks:
    # Check the host status, in case of a rerun, this task will fail avoiding to run the rest.
    - name: Check guest status
      ignore_errors: true
      register: check_guest_status_result
      ansible.builtin.wait_for_connection:
        timeout: 5

    # This task will gather all active user, excluding the ansible user
    - name: Check for active connections
      when: not check_guest_status_result.failed
      failed_when: check_active_connections.stderr | length > 0
      changed_when: check_active_connections.rc == 0
      register: check_active_connections
      ansible.builtin.shell: "w -h | grep -v {{ ansible_user }}"

    # If enable_debug is set the true, the previous command ouput will be displayed.
    # If the next task fail because there is active users sessions, enabling this task can help troubleshooting.
    - name: Display live connections
      when:
        - enable_debug | default('false') | bool
        - not check_guest_status_result.failed
      ansible.builtin.debug:
        var: check_active_connections.stdout_lines

    # Based on 'Check for active connections' output, if any user are connected, this task will end the playbook
    - name: Exit the host if there is still active connection
      when:
        - check_active_connections.stdout is defined
        - check_active_connections.stdout | length > 0
      ansible.builtin.fail:
        msg: "ERROR - There is still active session in {{ inventory_hostname }}"

    - name: Shutdown hosts
      when: not check_guest_status_result.failed
      community.general.shutdown:

    # This task add additional verification. The task will fail but it should fail as timeout.
    # The output will be captured and a condition in the next task will ensure that we are getting a timeout.
    - name: Make sure that all host are offline
      when: not check_guest_status_result.failed
      ignore_errors: true
      register: check_host_shutdown_result
      ansible.builtin.wait_for_connection:
        timeout: 2

    - name: Exit the playbook if the check command does not have the expected status
      when:
        - check_host_shutdown_result.failed is defined
        - not check_host_shutdown_result.failed
      ansible.builtin.fail:
        msg: "{{ inventory_hostname }} might still be online"

### SHUTDOWN ALL REMAINING VM
- name: Shutdown remaining VM
  hosts: pve_hypervisor_dev:pve_hypervisor_sandbox
  tags: all_vm_shutdown
  any_errors_fatal: true
  gather_facts: false
  tasks:
    # Check the host status, in case of a rerun, this task will fail avoiding to run the rest.
    - name: Check guest status
      ignore_errors: true
      register: check_guest_status_result
      ansible.builtin.wait_for_connection:
        timeout: 10
        when: not check_guest_status_result.failed

    # This task will gather a list of guest on the pve node.
    - name: List hypervisor virtual machines
      when: not check_guest_status_result.failed
      register: vm_list_result
      delegate_to: localhost
      community.proxmox.proxmox_vm_info:
        api_host: "{{ pve_api_node }}.{{ domain }}"
        api_user: "{{ pve_api_user }}"
        api_token_id: "{{ pve_api_token }}"
        api_token_secret: "{{ pve_api_secret }}"
        validate_certs: "{{ pve_cert_validation | bool | default('false') }}"
        node: "{{ inventory_hostname }}"

    # If enable_debug is set to true, the server list will be displayed by this task.
    - name: Display vm list output
      when:
        - enable_debug | default('false') | bool
        - item.status != 'stopped'
        - not check_guest_status_result.failed
      loop: "{{ vm_list_result.proxmox_vms }}"
      loop_control:
        label: "{{ item.name }}"
      ansible.builtin.debug:
        msg: "{{ item.name }} -- {{ item.vmid }} -- {{ item.status }}"

    # From the list, this task will turn off the 'start on boot' feature in all guests.
    - name: Ensure the start on boot feature is disabled
      when: not check_guest_status_result.failed
      delegate_to: localhost
      loop: "{{ vm_list_result.proxmox_vms }}"
      loop_control:
        label: "{{ item.name }}"
      community.proxmox.proxmox_kvm:
        api_host: "{{ pve_api_node }}.{{ domain }}"
        api_user: "{{ pve_api_user }}"
        api_token_id: "{{ pve_api_token }}"
        api_token_secret: "{{ pve_api_secret }}"
        validate_certs: "{{ pve_cert_validation | bool | default('false') }}"
        node: "{{ inventory_hostname }}"
        onboot: "false"
        vmid: "{{ item.vmid }}"
        update: true

    # The following block will shut down any remaining guest not returning the 'stopped' status.
    # The first task is regular shutdown through the qemu guest agent. The vm will received a shutdown signal.
    # If the task fail, then the recue will run the force shutdown. This will 'stop' the VM.
    # Killing the guest process at the node level, this is the last ressort shutdown.
    - name: Shudtown left over guest
      when: not check_guest_status_result.failed
      block:
        - name: Shutdown VM
          delegate_to: localhost
          when: item.status != 'stopped'
          loop: "{{ vm_list_result.proxmox_vms }}"
          loop_control:
            label: "{{ item.name }}"
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_node }}.{{ domain }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token }}"
            api_token_secret: "{{ pve_api_secret }}"
            validate_certs: "{{ pve_cert_validation | bool | default('false') }}"
            name: "{{ item.name }}"
            vmid: "{{ item.vmid }}"
            node: "{{ item.node }}"
            state: stopped
            force: "{{ force_guest_shutdown_rightaway | default('false') | bool }}"
      rescue:
        - name: Force shutdown VM
          delegate_to: localhost
          loop: "{{ vm_list_result.proxmox_vms }}"
          loop_control:
            label: "{{ item.name }}"
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_node }}.{{ domain }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token }}"
            api_token_secret: "{{ pve_api_secret }}"
            validate_certs: "{{ pve_cert_validation | bool | default('false') }}"
            name: "{{ item.name }}"
            vmid: "{{ item.vmid }}"
            node: "{{ item.node }}"
            state: stopped
            force: true

    # Once all guest are offline, the pause allow ceph to settle before enabling all the flag.
    - name: Waith for at least an hours for ceph to settle before shuting down the Nodes
      ansible.builtin.pause:
        minutes: 60

### ENSURE CEPH IS READY FOR SHUTDOWN
# Ceph storage is at the cluster level. All operation are run from a single pve node it will apply for the whole cluster.
# Ceph has a lot of feature to compensate for hardware failure. Enagling the follwing flag is essential before shutdown the nodes.
# The flag listed in 'ceph_flags' must stay in that order, they disable ceph feature one by one until putting the storage in pause.
# It is essential that no guest are left running because they will loose access to their drive.
- name: Ensure ceph is ready for shutdown
  hosts: pve-dev-master-01:pve-sdbx-master-01
  any_errors_fatal: true
  tags: ceph_shutdown
  gather_facts: false
  tasks:
    # Check the host status, in case of a rerun, this task will fail avoiding to run the rest.
    - name: Check guest status
      ignore_errors: true
      register: check_guest_status_result
      ansible.builtin.wait_for_connection:
        timeout: 10

    - name: Set ceph flags before shuting down the node
      when: not check_guest_status_result.failed
      delegate_to: "{{ item }}"
      register: set_ceph_flag_result
      changed_when: set_ceph_flag_result.rc == 0
      loop: "{{ ceph_flags }}"
      loop_control:
        label: "{{ item }}"
        pause: 60
      ansible.builtin.command: ceph osd set {{ item }}

    # This task gather ceph cluste status
    - name: Gather ceph status
      when: not check_guest_status_result.failed
      register: ceph_status_result
      changed_when: ceph_status_result.rc == 0
      ansible.builtin.command: "ceph -s"

    # Verify that all the flag are showing in the output
    - name: Print out ceph status
      when: not check_guest_status_result.failed
      ansible.builtin.debug:
        var: ceph_status_result.stdout_lines

    - name: 1h pause to check cepÄ¥ status
      ansible.builtin.pause:
        minutes: 60

### SHUTDING DOWN ALL PVE NODES
# Shutdown all pve node with proxmox api. This section can be run multiple time to ensure they are all down.
- name: Shutdown all PVE nodes from Dev and SandBox
  hosts: pve_hypervisor_dev:pve_hypervisor_sandbox
  tags: pve_shutdown
  gather_facts: false
  tasks:
    - name: Shutdown pve node
      ansible.builtin.uri:
        url: "https://{{ inventory_hostname }}.{{ domain }}:8006/api2/json/nodes/{{ inventory_hostname }}/status"
        method: POST
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token }}={{ pve_api_secret }}"
        body_format: form-urlencoded
        body:
          command: shutdown
        validate_certs: "{{ pve_cert_validation | bool | default('false') }}"
      delegate_to: localhost
